Option Explicit

Sub CopyGoldman_To_CONCILIACION_AndClean()
    Dim wsDATA As Worksheet, wsCONC As Worksheet, wsGold As Worksheet
    Dim lastRowGold As Long, lastColGold As Long
    Dim lastRowConc As Long, i As Long
    Dim valD As String, valK As String
    Dim rawA As String, rawL As String, dVal As Variant

    On Error Resume Next
    Set wsDATA = ThisWorkbook.Sheets("DATA")
    Set wsCONC = ThisWorkbook.Sheets("CONCILIACIÓN")
    If wsCONC Is Nothing Then Set wsCONC = ThisWorkbook.Sheets("CONCILIACION")
    Set wsGold = ThisWorkbook.Sheets("GOLDMAN")
    On Error GoTo 0

    If wsDATA Is Nothing Or wsCONC Is Nothing Or wsGold Is Nothing Then
        MsgBox "Required sheets not found (DATA / CONCILIACIÓN / GOLDMAN).", vbCritical
        Exit Sub
    End If

    Application.ScreenUpdating = False
    Application.EnableEvents = False

    ' 1) Clean DATA and CONCILIACIÓN
    wsDATA.Cells.Clear
    wsCONC.Cells.Clear

    ' 2) Copy all content from GOLDMAN to CONCILIACIÓN
    lastRowGold = wsGold.Cells(wsGold.Rows.Count, "A").End(xlUp).Row
    lastColGold = wsGold.Cells(1, wsGold.Columns.Count).End(xlToLeft).Column
    If lastRowGold >= 1 And lastColGold >= 1 Then
        wsGold.Range(wsGold.Cells(1, 1), wsGold.Cells(lastRowGold, lastColGold)).Copy wsCONC.Range("A1")
    End If

    ' 3) Delete rows in CONCILIACIÓN where column D says "Sell / Buy" (or "Sell/Buy")
    lastRowConc = wsCONC.Cells(wsCONC.Rows.Count, "D").End(xlUp).Row
    For i = lastRowConc To 2 Step -1
        valD = UCase$(Replace(Trim$(CStr(wsCONC.Cells(i, "D").Value)), " ", ""))
        If valD = "SELL/BUY" Then wsCONC.Rows(i).Delete
    Next i

    ' 4) Delete rows in CONCILIACIÓN where column K says "cardej" (exact, case-insensitive)
    lastRowConc = wsCONC.Cells(wsCONC.Rows.Count, "K").End(xlUp).Row
    For i = lastRowConc To 2 Step -1
        valK = UCase$(Trim$(CStr(wsCONC.Cells(i, "K").Value)))
        If valK = "CARDEJ" Then wsCONC.Rows(i).Delete
    Next i

    ' 4.5) Swap columns E and F (values + headers + basic number formats + column widths)
    Dim rngE As Range, rngF As Range
    Dim vE As Variant, vF As Variant
    Dim fmtE As String, fmtF As String
    Dim wE As Double, wF As Double

    lastRowConc = wsCONC.Cells(wsCONC.Rows.Count, "A").End(xlUp).Row
    If lastRowConc < 1 Then GoTo TidyExit

    Set rngE = wsCONC.Range("E1", wsCONC.Cells(lastRowConc, "E"))
    Set rngF = wsCONC.Range("F1", wsCONC.Cells(lastRowConc, "F"))

    ' swap values (includes headers)
    vE = rngE.Value
    vF = rngF.Value
    rngE.Value = vF
    rngF.Value = vE

    ' swap simple number formats
    fmtE = rngE.NumberFormat
    fmtF = rngF.NumberFormat
    rngE.NumberFormat = fmtF
    rngF.NumberFormat = fmtE

    ' swap column widths
    wE = wsCONC.Columns("E").ColumnWidth
    wF = wsCONC.Columns("F").ColumnWidth
    wsCONC.Columns("E").ColumnWidth = wF
    wsCONC.Columns("F").ColumnWidth = wE

    ' 5) Clean column A: drop time part and convert to real Date; format dd-mmm-yy
    lastRowConc = wsCONC.Cells(wsCONC.Rows.Count, "A").End(xlUp).Row
    For i = 2 To lastRowConc
        rawA = Trim$(CStr(wsCONC.Cells(i, "A").Value))
        If Len(rawA) > 0 Then
            ' Keep only text after the first space (e.g., "07:50:39AM 29 Aug 25" -> "29 Aug 25")
            If InStr(rawA, " ") > 0 Then rawA = Mid$(rawA, InStr(rawA, " ") + 1)
            dVal = ParseTokenToDate(rawA)
            If IsDate(dVal) Then
                wsCONC.Cells(i, "A").Value = dVal   ' write as real Date
            End If
        End If
    Next i
    wsCONC.Range("A2:A" & lastRowConc).NumberFormat = "dd-mmm-yy"

    ' 6) Normalize column L to real Date; format dd-mmm-yy
    lastRowConc = wsCONC.Cells(wsCONC.Rows.Count, "L").End(xlUp).Row
    For i = 2 To lastRowConc
        rawL = Trim$(CStr(wsCONC.Cells(i, "L").Value))
        If Len(rawL) > 0 Then
            dVal = ParseTokenToDate(rawL)
            If IsDate(dVal) Then
                wsCONC.Cells(i, "L").Value = dVal
            End If
        End If
    Next i
    wsCONC.Range("L2:L" & lastRowConc).NumberFormat = "dd-mmm-yy"

    MsgBox "GOLDMAN → CONCILIACIÓN done: removed D='Sell / Buy', K='cardej', swapped E↔F, and normalized dates in A & L.", vbInformation

TidyExit:
    Application.CutCopyMode = False
    Application.EnableEvents = True
    Application.ScreenUpdating = True
End Sub

' ===== Helpers =====

Private Function MonthFromAbbrev(ByVal s As String) As Integer
    Dim m As String
    m = LCase$(Left$(Trim$(s), 3))
    Select Case m
        Case "jan": MonthFromAbbrev = 1
        Case "feb": MonthFromAbbrev = 2
        Case "mar": MonthFromAbbrev = 3
        Case "apr": MonthFromAbbrev = 4
        Case "may": MonthFromAbbrev = 5
        Case "jun": MonthFromAbbrev = 6
        Case "jul": MonthFromAbbrev = 7
        Case "aug": MonthFromAbbrev = 8
        Case "sep": MonthFromAbbrev = 9
        Case "oct": MonthFromAbbrev = 10
        Case "nov": MonthFromAbbrev = 11
        Case "dec": MonthFromAbbrev = 12
    End Select
End Function

' Returns a real Date (Variant/Date) for tokens like:
'   "29Aug25", "29-aug-25", "29 Aug 25"
' If it can’t parse, returns Empty.
Private Function ParseTokenToDate(ByVal txt As String) As Variant
    Dim s As String, d As Integer, y As Integer, m As Integer
    Dim parts() As String

    s = Trim$(txt)
    If s = "" Then Exit Function

    ' dd-mmm-yy (hyphens) e.g., 29-aug-25
    If Len(s) >= 8 And Mid$(s, 3, 1) = "-" And Mid$(s, 7, 1) = "-" Then
        On Error Resume Next
        d = CInt(Left$(s, 2))
        m = MonthFromAbbrev(Mid$(s, 4, 3))
        y = CInt(Right$(s, 2))
        If Err.Number = 0 And d >= 1 And d <= 31 And m >= 1 Then
            ParseTokenToDate = DateSerial(2000 + y, m, d)
            Exit Function
        End If
        Err.Clear
        On Error GoTo 0
    End If

    ' ddMmmyy (no separators) e.g., 29Aug25
    If Len(s) >= 7 And IsNumeric(Left$(s, 2)) And Not IsNumeric(Mid$(s, 3, 1)) Then
        On Error Resume Next
        d = CInt(Left$(s, 2))
        m = MonthFromAbbrev(Mid$(s, 3, 3))
        y = CInt(Right$(s, 2))
        If Err.Number = 0 And d >= 1 And d <= 31 And m >= 1 Then
            ParseTokenToDate = DateSerial(2000 + y, m, d)
            Exit Function
        End If
        Err.Clear
        On Error GoTo 0
    End If

    ' dd mmm yy (spaces) e.g., 29 Aug 25
    If InStr(s, " ") > 0 Then
        parts = Split(s, " ")
        If UBound(parts) = 2 Then
            On Error Resume Next
            d = CInt(parts(0))
            m = MonthFromAbbrev(parts(1))
            y = CInt(parts(2))
            If Err.Number = 0 And d >= 1 And d <= 31 And m >= 1 Then
                ParseTokenToDate = DateSerial(2000 + y, m, d)
                Exit Function
            End If
            Err.Clear
            On Error GoTo 0
        End If
    End If
End Function